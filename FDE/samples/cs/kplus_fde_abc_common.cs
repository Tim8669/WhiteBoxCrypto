/**
 * Copyright 2013-2015 KryptoLogik.com
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Generated by: KryptoPlus 1.3.0-136
 *
 */

/*** This file may be modified for custom formats ***/

using System;

namespace kplus.fde.abc {
    public class Format {
        private Format() {}
        public static uint keyId() { return 0x0ECE8E7C; }
        public static uint keyAttr() { return 0x010303D2; }
        public static uint packSize() { return 16; }
        
        public static uint radix = 10;
        public static string CharSet = "0123456789";

        /**
         * Converts plian/cipher text strings to internal byte array.
         * Characters not found in the <CharSet> are taken as formatting
         * characters.
         * 
         * @param data_in user supplied plain/cipher text
         */
        public static byte[] Pack(string data_in) {
            byte[] packed_data = new byte[16];
            int n = 0;
            foreach (char c in data_in) {
                int i = Format.CharSet.IndexOf(c);
                if (i >= 0) {
                    packed_data[n++] = (byte)i;
                    if (n == 16) return packed_data;
                }
            }

            throw new Exception("Input too short!");
        }
        
        /**
         * Converts internal byte array to external textual format according
         * to the input template
         *
         * @param packed_data  Internal format data
         * @param tmpl Template to use for conversion
         */
        public static string Unpack(byte[] packed_data, string tmpl) {
            int n = 0;
            string s = "";
            foreach (char c in tmpl) {
                if (n < 16 && Format.CharSet.IndexOf(c) >= 0) {
                    s = s + Format.CharSet[packed_data[n++] % 10];
                } else {
                    s = s + c;
                }
            }
            if (n != 16) 
                throw new Exception("Template too short!");
            return s;
        }
    }
}
